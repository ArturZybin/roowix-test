{"version":3,"sources":["components/TableCell.tsx","components/Table.tsx","components/SelectionLayer.tsx","components/EditorCell.tsx","components/Editor.tsx","App.tsx","index.tsx"],"names":["TableCell","isRight","selectionCoords","setSelected","ref","useRef","isSelected","element","start","x","y","end","areSelectionCoordsExist","rect","getBoundingClientRect","elLeft","elRight","width","elTop","window","pageYOffset","elBottom","height","selectionLeft","Math","min","selectionRight","max","selectionTop","selectionBottom","checkIsSelected","current","useEffect","className","Table","matrix","setSelectedCell","selectedCellsPosition","tableRef","thead","length","weekdays","theadInner","key","i","push","createThead","tbody","tbodyInner","map","row","rowIndex","trowInner","cell","cellIndex","matrixPosition","status","createTbody","selectedCellsBorder","cellsPosition","table","left","rows","cells","top","style","createSelectedCellsBorder","SelectionLayer","selectionStyles","setSelectionCoords","openEditor","useState","isSelection","setIsSelection","startCoords","setStartCoords","endCoords","setEndCoords","selectionLayerRef","startSelection","event","pageX","pageY","layer","document","addEventListener","handleSelection","stopSelection","removeEventListener","areCoordsExist","abs","getSelectionStyles","EditorCell","handleChangeStatus","setStatus","onClick","Editor","matrixCopy","closeEditor","applyChanges","editableMatrix","setEditableMatrix","newEditableMatrix","matrixLength","fakeRowInner","createDecorativeRow","App","state","selectedMatrix","editableCellsPosition","position","setState","prevState","newSelectedMatrix","calculateSelectedCellsPosition","handleOpenEditor","handleCloseEditor","handleApplyEditorChanges","newMatrix","this","React","Component","selectedMatrixCopy","lastRowIndex","lastCellIndex","startPosition","endPosition","forEach","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.c546940b.chunk.js","sourcesContent":["import React, { useRef, useEffect } from 'react'\r\nimport { ISelectionCoords } from '../types'\r\n\r\ninterface IProps {\r\n   isRight: boolean,\r\n   selectionCoords: ISelectionCoords,\r\n   matrixPosition: [number, number],\r\n   setSelected: (status: boolean) => void\r\n}\r\n\r\n\r\nexport const TableCell: React.FC<IProps> = ({ isRight, selectionCoords, setSelected }) => {\r\n   const ref = useRef(null)\r\n   const isSelected = checkIsSelected(ref.current, selectionCoords)\r\n   useEffect(() => {\r\n      setSelected(isSelected)\r\n   // eslint-disable-next-line react-hooks/exhaustive-deps\r\n   }, [isSelected])\r\n\r\n\r\n   let className = 'table__cell '\r\n   className += isSelected ? 'table__cell_selected ' : ''\r\n   className += isRight ? 'table__cell_right' : ''\r\n\r\n   return (\r\n      <td ref={ref} className={className} />\r\n   )\r\n}\r\n\r\n\r\nfunction checkIsSelected(element: HTMLTableElement | null, selectionCoords: ISelectionCoords): boolean {\r\n   if (!element || !areSelectionCoordsExist(selectionCoords)) return false\r\n\r\n   const rect = element.getBoundingClientRect()\r\n   const elLeft = rect.x\r\n   const elRight = elLeft + rect.width\r\n   const elTop = window.pageYOffset + rect.y\r\n   const elBottom = elTop + rect.height\r\n\r\n   const selectionLeft = Math.min(selectionCoords?.start.x as number, selectionCoords?.end.x as number)\r\n   const selectionRight = Math.max(selectionCoords?.start.x as number, selectionCoords?.end.x as number)\r\n   const selectionTop = Math.min(selectionCoords?.start.y as number, selectionCoords?.end.y as number)\r\n   const selectionBottom = Math.max(selectionCoords?.start.y as number, selectionCoords?.end.y  as number)\r\n\r\n   if (elRight > selectionLeft &&\r\n      elLeft < selectionRight &&\r\n      elBottom > selectionTop &&\r\n      elTop < selectionBottom) return true\r\n\r\n   return false\r\n}\r\n\r\n\r\nfunction areSelectionCoordsExist(selectionCoords: ISelectionCoords) {\r\n   return selectionCoords?.start.x !== null &&\r\n      selectionCoords?.start.y !== null &&\r\n      selectionCoords?.end.x !== null &&\r\n      selectionCoords?.end.y !== null\r\n}","import React, { useRef } from 'react'\nimport { TMatrix, ISelectionCoords, ISelectedCellsPosition } from '../types'\nimport { TableCell } from './TableCell'\n\n\ninterface IProps {\n   matrix: TMatrix,\n   selectionCoords: ISelectionCoords,\n   setSelectedCell: (position: [number, number], status: boolean) => void,\n   selectedCellsPosition: ISelectedCellsPosition,\n}\n\nexport const Table: React.FC<IProps> = ({ matrix, selectionCoords, setSelectedCell, selectedCellsPosition }) => {\n   const tableRef = useRef(null)\n   const thead = createThead(matrix[1].length)\n   const tbody = createTbody()\n\n\n   function createTbody(): JSX.Element {\n      const tbodyInner: JSX.Element[] = matrix.map((row, rowIndex) => {\n\n         const trowInner: JSX.Element[] = row.map((cell, cellIndex) => {\n            const setSelected = (status: boolean) => setSelectedCell([rowIndex, cellIndex], status)\n\n            return (<TableCell\n               key={cellIndex}\n               isRight={!!cell}\n               selectionCoords={selectionCoords}\n               matrixPosition={[rowIndex, cellIndex]}\n               setSelected={setSelected}\n            />)\n         })\n\n         return (\n            <tr key={rowIndex}>\n               <td className=\"table__day-number\">номер {rowIndex + 1}</td>\n               {trowInner}\n            </tr>\n         )\n      })\n\n      return <tbody>{tbodyInner}</tbody>\n   }\n\n   const selectedCellsBorder = createSelectedCellsBorder(tableRef, selectedCellsPosition)\n\n\n   return (\n      <>\n         <table ref={tableRef} className=\"table\">\n            {thead}\n            {tbody}\n         </table>\n         {selectedCellsBorder}\n      </>\n   )\n}\n\n\nfunction createThead(length: number): JSX.Element {\n   const weekdays = ['пн', 'вт', 'ср', 'чт', 'пт']\n   const theadInner: JSX.Element[] = [<td key={7}></td>]\n\n   for (let i = 0; i < length; i++) {\n      theadInner.push(<td key={i} className=\"table__head-cell\">{weekdays[i]}</td>)\n   }\n\n   return <thead><tr>{theadInner}</tr></thead>\n}\n\n\nfunction createSelectedCellsBorder(tableRef: React.MutableRefObject<null>, cellsPosition: ISelectedCellsPosition): JSX.Element {\n   if (cellsPosition.start.row === -1\n      || cellsPosition.start.cell === -1\n      || cellsPosition.end.row === -1\n      || cellsPosition.end.cell === -1\n      || !tableRef.current\n   ) return (<></>)\n\n   const width = (cellsPosition.end.cell - cellsPosition.start.cell + 1) * 52 - 2\n   const height = (cellsPosition.end.row - cellsPosition.start.row + 1) * 54 - 2\n   const table = tableRef.current as unknown as HTMLTableElement\n   const left = table.rows[0].cells[cellsPosition.start.cell + 1].getBoundingClientRect().left\n   const top = table.rows[cellsPosition.start.row + 1].getBoundingClientRect().top + window.pageYOffset\n\n   return (\n      <div className=\"selected-cells-border\" style={{ left, top, width, height }}>\n         <div className=\"selected-cells-border__angle-square\"></div>\n         <div className=\"selected-cells-border__angle-square\"></div>\n         <div className=\"selected-cells-border__angle-square\"></div>\n         <div className=\"selected-cells-border__angle-square\"></div>\n         <div className=\"selected-cells-border__size-label\">{width}×{height}</div>\n      </div>\n   )\n}","import React, { useState, useEffect, useRef } from 'react'\r\nimport { ISelectionCoords } from '../types';\r\n\r\ninterface IProps {\r\n   setSelectionCoords: (selectionCoords: ISelectionCoords) => void,\r\n   openEditor: () => void\r\n}\r\n\r\n\r\nexport const SelectionLayer: React.FC<IProps> = ({ setSelectionCoords, openEditor }) => {\r\n   const [isSelection, setIsSelection] = useState<boolean>(false)\r\n   const [startCoords, setStartCoords] = useState<number[] | null[]>([null, null])\r\n   const [endCoords, setEndCoords] = useState<number[] | null[]>([null, null])\r\n\r\n   const selectionLayerRef = useRef(null)\r\n\r\n   useEffect(() => {\r\n      const layer = selectionLayerRef.current as unknown as HTMLElement\r\n      layer.addEventListener('mousedown', startSelection)\r\n      return () => layer.removeEventListener('mousedown', startSelection)\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n   }, [])\r\n\r\n\r\n   useEffect(() => {\r\n      if (!areCoordsExist(startCoords, endCoords)) return\r\n      setSelectionCoords({\r\n         start: { x: startCoords[0], y: startCoords[1] },\r\n         end: { x: endCoords[0], y: endCoords[1] }\r\n      })\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n   }, [startCoords[0], startCoords[1], endCoords[0], endCoords[1]])\r\n\r\n\r\n   function startSelection(event: MouseEvent) {\r\n      setIsSelection(true)\r\n      setStartCoords([event.pageX, event.pageY])\r\n      setEndCoords([event.pageX, event.pageY])\r\n\r\n      const layer = selectionLayerRef.current as unknown as HTMLElement\r\n      document.addEventListener('mousemove', handleSelection)\r\n      layer.addEventListener('mouseup', stopSelection)\r\n   }\r\n\r\n   function handleSelection(event: MouseEvent) {\r\n      setEndCoords([event.pageX, event.pageY])\r\n   }\r\n\r\n   function stopSelection() {\r\n      setIsSelection(false)\r\n      setStartCoords([null, null])\r\n      setEndCoords([null, null])\r\n\r\n      setSelectionCoords({\r\n         start: { x: null, y: null },\r\n         end: { x: null, y: null }\r\n      })\r\n      openEditor()\r\n\r\n      const layer = selectionLayerRef.current as unknown as HTMLElement\r\n      document.removeEventListener('mousemove', handleSelection)\r\n      layer.removeEventListener('mouseup', stopSelection)\r\n   }\r\n\r\n\r\n   let selectionStyles\r\n   if (areCoordsExist(startCoords, endCoords)) {\r\n      selectionStyles = getSelectionStyles(startCoords as number[], endCoords as number[])\r\n   }\r\n\r\n   return (\r\n      <div className=\"selection-layer\" ref={selectionLayerRef}>\r\n         {isSelection && <div className=\"selection-layer__selection\" style={selectionStyles}></div>}\r\n      </div>\r\n   )\r\n}\r\n\r\n\r\nfunction getSelectionStyles(startCoords: number[], endCoords: number[]) {\r\n   const left = Math.min(startCoords[0], endCoords[0])\r\n   const top = Math.min(startCoords[1], endCoords[1])\r\n   const width = Math.abs(endCoords[0] - startCoords[0])\r\n   const height = Math.abs(endCoords[1] - startCoords[1])\r\n\r\n   return { left, top, width, height }\r\n}\r\n\r\n\r\nfunction areCoordsExist(startCoords: number[] | null[], endCoords: number[] | null[]) {\r\n   return startCoords[0] !== null && startCoords[1] !== null && endCoords[0] !== null && endCoords[1] !== null\r\n}","import React, { useState } from 'react'\n\n\ninterface IProps {\n   isRight: boolean,\n   handleChangeStatus: (status: boolean) => void,\n}\n\nexport const EditorCell: React.FC<IProps> = ({isRight, handleChangeStatus}) => {\n   const [status, setStatus] = useState(isRight)\n\n   function toggleStatus() {\n      setStatus(!status)\n      handleChangeStatus(!status)\n   }\n\n   let className = 'editor__cell '\n   if (status) {\n      className += 'editor__cell_checked'\n   }\n\n   return (\n      <td onClick={toggleStatus} className={className}></td>\n   )\n}","import React, { useState } from 'react'\nimport { ISelectedCellsPosition } from '../types'\nimport { EditorCell } from './EditorCell'\n\n\ninterface IProps {\n   matrixCopy: number[][],\n   cellsPosition: ISelectedCellsPosition,\n   closeEditor: () => void\n   applyChanges: (newMatrix: number[][]) => void\n}\n\nexport const Editor: React.FC<IProps> = ({ matrixCopy, cellsPosition, closeEditor, applyChanges }) => {\n   const [editableMatrix, setEditableMatrix] = useState<number[][]>(matrixCopy)\n\n   const thead = createThead(cellsPosition.start.cell, cellsPosition.end.cell)\n   const tbody = createTbody()\n\n\n   function createTbody(): JSX.Element {\n      const tbodyInner: JSX.Element[] = []\n\n      for (let rowIndex = cellsPosition.start.row; rowIndex <= cellsPosition.end.row; rowIndex++) {\n         const trowInner: JSX.Element[] = []\n         for (let cellIndex = cellsPosition.start.cell; cellIndex <= cellsPosition.end.cell; cellIndex++) {\n\n            const handleChangeStatus = (status: boolean) => {\n               const newEditableMatrix = editableMatrix.map((row) => [...row])\n               newEditableMatrix[rowIndex][cellIndex] = status ? 1 : 0\n               setEditableMatrix(newEditableMatrix)\n            }\n\n            trowInner.push(<EditorCell\n               key={cellIndex}\n               isRight={!!matrixCopy[rowIndex][cellIndex]}\n               handleChangeStatus={handleChangeStatus}\n            />)\n         }\n\n         tbodyInner.push(\n            <tr key={rowIndex}>\n               <td className=\"editor__day-number\">номер {rowIndex + 1}</td>\n               {trowInner}\n            </tr>\n         )\n      }\n\n      tbodyInner.push(createDecorativeRow(cellsPosition, editableMatrix.length))\n\n      return <tbody>{tbodyInner}</tbody>\n   }\n\n\n   return (\n      <div className=\"background-locker\">\n         <div className=\"editor\">\n            <table className=\"editor__table\">\n               {thead}\n               {tbody}\n            </table>\n            <button\n               className=\"editor__button editor__button_type_decline\"\n               onClick={closeEditor}\n            >\n               Отменить\n            </button>\n            <button\n               className=\"editor__button editor__button_type_accept\"\n               onClick={() => applyChanges(editableMatrix)}\n            >\n               Применить\n            </button>\n         </div>\n      </div>\n   )\n}\n\n\nfunction createThead(start: number, end: number): JSX.Element {\n   const weekdays = ['пн', 'вт', 'ср', 'чт', 'пт']\n   const theadInner: JSX.Element[] = [<td key={7}></td>]\n\n   for (let i = start; i <= end; i++) {\n      theadInner.push(<td key={i} className=\"editor__head-cell\">{weekdays[i]}</td>)\n   }\n\n   return <thead><tr>{theadInner}</tr></thead>\n}\n\n\nfunction createDecorativeRow(cellsPosition: ISelectedCellsPosition, matrixLength: number): JSX.Element {\n   const fakeRowInner: JSX.Element[] = []\n   for (let cellIndex = cellsPosition.start.cell; cellIndex <= cellsPosition.end.cell + 1; cellIndex++) {\n      fakeRowInner.push(<td className=\"editor__fake-cell\" key={cellIndex}></td>)\n   }\n\n   return (<tr key={matrixLength}>{fakeRowInner}</tr>)\n}","import React from 'react';\n\nimport 'normalize.css';\nimport './styles/style.scss';\n\nimport { Table } from './components/Table';\nimport { SelectionLayer } from './components/SelectionLayer';\nimport { ISelectionCoords, ISelectedCellsPosition } from './types';\nimport { Editor } from './components/Editor';\n\n\ninterface IState {\n   matrix: number[][],\n   selectionCoords: ISelectionCoords,\n   selectedMatrix: number[][],\n   openEditor: boolean,\n   selectedCellsPosition: ISelectedCellsPosition,\n   editableCellsPosition: ISelectedCellsPosition\n}\n\nclass App extends React.Component<{}, IState> {\n   state = {\n      matrix: [\n         [1, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0],\n         [1, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0]\n      ],\n      selectionCoords: {\n         start: { x: null, y: null },\n         end: { x: null, y: null }\n      },\n      selectedMatrix: [\n         [0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0]\n      ],\n      openEditor: false,\n      selectedCellsPosition: {\n         start: {\n            row: -1,\n            cell: -1\n         },\n         end: {\n            row: -1,\n            cell: -1\n         }\n      },\n      editableCellsPosition: {\n         start: {\n            row: -1,\n            cell: -1\n         },\n         end: {\n            row: -1,\n            cell: -1\n         }\n      }\n   }\n\n\n   setSelectedCell = (position: [number, number], status: boolean): void => {\n      this.setState((prevState: IState) => {\n         const newSelectedMatrix = prevState.selectedMatrix.map((row) => [...row])\n         newSelectedMatrix[position[0]][position[1]] = status ? 1 : 0\n\n         const selectedCellsPosition = calculateSelectedCellsPosition(newSelectedMatrix)\n\n         return { selectedMatrix: newSelectedMatrix, selectedCellsPosition }\n      })\n   }\n\n\n   setSelectionCoords = (selectionCoords: ISelectionCoords) => {\n      this.setState({ selectionCoords })\n   }\n\n\n   handleOpenEditor = () => {\n      const { selectedCellsPosition } = this.state\n      if (selectedCellsPosition.start.row === -1) return\n\n      this.setState({\n         openEditor: true,\n         editableCellsPosition: {\n            start: {\n               row: selectedCellsPosition.start.row,\n               cell: selectedCellsPosition.start.cell\n            },\n            end: {\n               row: selectedCellsPosition.end.row,\n               cell: selectedCellsPosition.end.cell\n            }\n         }\n      })\n   }\n\n\n   handleCloseEditor = () => {\n      this.setState({\n         openEditor: false,\n         selectedCellsPosition: {\n            start: {\n               row: -1,\n               cell: -1\n            },\n            end: {\n               row: -1,\n               cell: -1\n            }\n         }\n      })\n   }\n\n\n   handleApplyEditorChanges = (newMatrix: number[][]) => {\n      this.setState({\n         matrix: newMatrix,\n         openEditor: false,\n         selectedCellsPosition: {\n            start: {\n               row: -1,\n               cell: -1\n            },\n            end: {\n               row: -1,\n               cell: -1\n            }\n         }\n      })\n   }\n\n\n   render() {\n      const { matrix, selectionCoords, openEditor, selectedCellsPosition, editableCellsPosition } = this.state\n      const matrixCopy = matrix.map((row) => [...row])\n\n      return (\n         <>\n            <Table\n               matrix={matrix}\n               selectionCoords={selectionCoords}\n               setSelectedCell={this.setSelectedCell}\n               selectedCellsPosition={selectedCellsPosition}\n            />\n            <SelectionLayer\n               setSelectionCoords={this.setSelectionCoords}\n               openEditor={this.handleOpenEditor}\n            />\n            {openEditor &&\n               <Editor\n                  matrixCopy={matrixCopy}\n                  cellsPosition={editableCellsPosition}\n                  closeEditor={this.handleCloseEditor}\n                  applyChanges={this.handleApplyEditorChanges}\n               />}\n         </>\n      )\n   }\n}\n\nexport default App;\n\n\n\nfunction calculateSelectedCellsPosition(selectedMatrix: number[][]): ISelectedCellsPosition {\n   const selectedMatrixCopy = selectedMatrix.map((row) => [...row])\n   const lastRowIndex = selectedMatrix.length - 1\n   const lastCellIndex = selectedMatrix.length - 1\n\n   let startPosition: [number, number] | null = null\n   let endPosition: [number, number] | null = null\n\n   selectedMatrixCopy.forEach((row, rowIndex) => {\n      row.forEach((cell, cellIndex) => {\n         if (!startPosition && cell) {\n            startPosition = [rowIndex, cellIndex]\n         }\n\n         if (startPosition && cell\n            && (rowIndex === lastRowIndex || !selectedMatrixCopy[rowIndex + 1][cellIndex])\n            && (cellIndex === lastCellIndex || !selectedMatrixCopy[rowIndex][cellIndex + 1])\n         ) {\n            endPosition = [rowIndex, cellIndex]\n         }\n      })\n   })\n\n   if (!startPosition) {\n      startPosition = [-1, -1]\n   }\n   if (!endPosition) {\n      endPosition = [-1, -1]\n   }\n\n   return ({\n      start: {\n         row: startPosition[0],\n         cell: startPosition[1]\n      },\n      end: {\n         row: endPosition[0],\n         cell: endPosition[1]\n      }\n   })\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n   <React.StrictMode>\n      <App />\n   </React.StrictMode>,\n   document.getElementById('root')\n);"],"sourceRoot":""}